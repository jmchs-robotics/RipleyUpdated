// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5933.Ripley2019.subsystems;


import org.usfirst.frc5933.Ripley2019.Robot;
import org.usfirst.frc5933.Ripley2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Arm extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX armSubsystemMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
	private static final int encoderSide = 1; // 1 for encoder on the left when facing the arm (Eve), -1 for Ripley?
	// vbusPolarity corrects for the motor being on opposite sides of the sprocket on Eve vs on Ripley 
	// In other words, motor polarity vs encoder polarity. -1.0 for Eve, 1.0 for Ripley?
	private static final double vbusPolarity = -1.0; 
	// confirm which way students want to drive
	private static final double joyStickPolarity = -1.0; 
	// hitting limit switch stops the motor. If driving the arm downwads is green on the talon, this should be -1.
	private static final double limitSwitchPolarity = 1.0; 
	public static double kDown = 0.005; //0.15; // target vBus proportional coefficient for moving the arm down. Should be positive.
	public static double kUp = 0.005; //0.18;  // target vBus proportional coefficient for moving the arm up. Should be positive.
	public static double vBusDownMax = -1.0; // probably don’t want to lower at top speed. Should be a negative number.
	public static double vBusUpMax = 1.0; // probably full power, positive
		// may want a vBusUpMin = 0.2 to make sure we always overcome gravity and static friction...
	public static boolean encoderPositioningUnderway = false; // true when the subsystem operator is holding one of the encoder position buttons (X, Y, A, whatever)
	public static double encoderTargetPosition = 0; // set when user hits an encoder-based desired position
	public static double bottomEncoder = 0; // value of the encoder whenever the lower switch is triggered
	public static double topEncoder = 1100; // value of the encoder whenever the upper switch is triggered
	public static int rocketHatchOne = 99;
	public static int rocketHatchTwo = 751;
	public static int rocketHatchThree = 1235;

    public int blindCounter = 0;

    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		armSubsystemMotor = new WPI_TalonSRX(20);
		       
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    // ArmPosition lastPos = ArmPosition.Start; // from Eve 2018

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
	}
	/** 
 	* Configure the Talon to work from vbus, to limit its current draw...
 	*/
	public void init() {
		/* 
		// Eve set up limits etc in the Talon.
		// Ripley enforcing vbus limits within this Class.
        // setArmFeedback(10);

		armSubsystemMotor.configForwardSoftLimitEnable(false, 10);
		armSubsystemMotor.configReverseSoftLimitEnable(false, 10);

		armSubsystemMotor.configNominalOutputForward(0, 10);
		armSubsystemMotor.configNominalOutputReverse(0, 10);
		armSubsystemMotor.configPeakOutputForward(0.2, 10);//armSubsystemMotor.configPeakOutputForward(1, 10);
		armSubsystemMotor.configPeakOutputReverse(-1, 10);
		
		armSubsystemMotor.configClosedloopRamp(0.5, 10); //seconds to full frontal val. Should help stop swinging. Could also use d-coeff.
		*/

		// prevent browning out
		armSubsystemMotor.configPeakCurrentLimit( 0, 0);  
		armSubsystemMotor.configPeakCurrentDuration( 0, 0);
		armSubsystemMotor.configContinuousCurrentLimit( 10, 0);
		armSubsystemMotor.enableCurrentLimit(true);
		armSubsystemMotor.configPeakOutputForward(1, 0);//armSubsystemMotor.configPeakOutputForward(1, 10);
		armSubsystemMotor.configPeakOutputReverse(-1, 0);
		armSubsystemMotor.configVoltageCompSaturation( 12, 0);

		// stop the motor
		armSubsystemMotor.set( ControlMode.PercentOutput, 0);
		
	}

        public void moveArm() {
            boolean lowerSwitch = Robot.roboRio.DIPs[0].get();
            boolean upperSwitch = Robot.roboRio.DIPs[1].get();
			double j = Robot.oi.subsystemJoystick.getLeftY() * this.joyStickPolarity;
			
			// armSubsystemMotor.set(j);
			setArmMotorVbus( j);
           
		}
		/** 
		 * call when user wants the arm to automatically move to, and stay at, 
		 * a specific position, via our own PID loop code (in periodic()). 
		 * @param desiredGoalPositioning 
		 * 		1 for low rocket / loading station / cargo ship height; 
		 * 		2 for medium rocket height; 
		 * 		3 for high rocket height
		 */
        public void startEncoderPositioning(int desiredGoalPositioning) {
			int rocketOne = 1;
			int rocketTwo = 2;
			int rocketThree = 3;
			encoderPositioningUnderway = true;
			if (desiredGoalPositioning == rocketOne) {
				encoderTargetPosition = bottomEncoder + rocketHatchOne;
			} else if (desiredGoalPositioning == rocketTwo) {
				encoderTargetPosition = bottomEncoder + rocketHatchTwo;
			} else if (desiredGoalPositioning == rocketThree) {
				encoderTargetPosition = bottomEncoder + rocketHatchThree;
			} else {
				encoderPositioningUnderway = false;
			}
		}
		/** 
		 * return control of the arm to the joystick 
		 * */
		public void endEncoderPositioning() {
			encoderPositioningUnderway = false;
		}

        public void readArm() {
            SmartDashboard.putNumber("Arm Speed:", armSubsystemMotor.get());
        }
	
	/**
	 * read the encoder and correct for it's side set 'encoderSide' to 1 or -1 so
	 * this function returns a more positive number when the arm rises
	 * 
	 * @return encoder position
	 */
        public double readEncoder() {
			double pos = armSubsystemMotor.getSelectedSensorPosition() * encoderSide;
			SmartDashboard.putNumber("Raw Enc Pos * encoderSide: ", pos);
			return pos;
        }

        public void stop(){
            armSubsystemMotor.stopMotor();
        }

        public void armUp(){
			// armSubsystemMotor.set(0.7);
			setArmMotorVbus(0.7);
        }         

        public void armDown(){
			// armSubsystemMotor.set(-0.7);
			setArmMotorVbus(-0.7);
		}

		/** 
		 * correct for side (and/or polarity) of motor compared to sprocket/arm, using vbusPolarity
		 * stop the motor if trying to drive past a limit switch
		 */
		public void setArmMotorVbus( double vbus) {
			boolean lowerSwitch = Robot.roboRio.DIPs[0].get();
			boolean upperSwitch = Robot.roboRio.DIPs[1].get();
			
			double v = vbus * vbusPolarity;
			if( v * limitSwitchPolarity < 0 && !lowerSwitch){
				v = 0;
			}
			if( v * limitSwitchPolarity > 0 && !upperSwitch) {
				v = 0;
			}
			if( v > 1) {
				v = 1;
			}
			if( v < -1) {
				v = -1;
			}
			
			armSubsystemMotor.set( ControlMode.PercentOutput, v);
		}

    public void periodic() {
        // Put code here to be run every loop

		readArm();
		// read current encoder position (already corrected for the side)
        double pos = readEncoder();

		SmartDashboard.putNumber("Enc pos when lower switch hit", bottomEncoder);

		// Whenever a limit switch is active (which drives the DIO to zero) we want to reset the relevant 
		//  encoder position (member) to the current encoder position
		boolean lowerSwitch = Robot.roboRio.DIPs[0].get(); 
		if ( !lowerSwitch) {
			bottomEncoder = pos;
		}
		
		boolean upperSwitch = Robot.roboRio.DIPs[1].get();
		if (!upperSwitch) { 
			topEncoder = pos;
		}

		// if subsystem driver has selected an encoder-based positioning button, perform it
		if (encoderPositioningUnderway == true) {
			// error is the difference between the desired position and the current position
			double e = encoderTargetPosition - pos;  
			double vBus = 0;
			SmartDashboard.putNumber("arm error", e);
			if (e < 0) {  // need to lower the arm, but don’t want to lower too quickly 
				vBus = e * kDown; /* kDown; 
				if (vBus < vBusDownMax) { 
					vBus = vBusDownMax; 
				}  */
				/* if (!lowerSwitch) { // don't drive past the limit switch
					vBus = 0; 
				}*/ 
			}  
			if (e >= 0) { 
				vBus = e * kUp; /*
				if (vBus > vBusUpMax) { // can’t go faster than top speed
					vBus = vBusUpMax; 
				} */
				/* if (!upperSwitch) { // don't drive past the limit switch
					vBus = 0; 
			} */
			}
			// armSubsystemMotor.set(vBus);
			setArmMotorVbus( vBus);
		} else { // otherwise subsystem driver is using the joystick
			moveArm(); // standard joystick-based arm movement
			SmartDashboard.putBoolean("Arm is a-go: ", true);
		}
	

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
	// here. Call these from Commands.
	

}

